é¡¹ç›® 'goblin-2api' çš„ç»“æž„æ ‘:
ðŸ“‚ goblin-2api/
    ðŸ“„ .env
    ðŸ“„ .env.example
    ðŸ“„ Dockerfile
    ðŸ“„ docker-compose.yml
    ðŸ“„ main.py
    ðŸ“„ nginx.conf
    ðŸ“„ requirements.txt
    ðŸ“‚ app/
        ðŸ“‚ core/
            ðŸ“„ __init__.py
            ðŸ“„ config.py
        ðŸ“‚ providers/
            ðŸ“„ __init__.py
            ðŸ“„ base_provider.py
            ðŸ“„ goblin_provider.py
        ðŸ“‚ utils/
            ðŸ“„ sse_utils.py
================================================================================

--- æ–‡ä»¶è·¯å¾„: .env ---

# [è‡ªåŠ¨å¡«å……] goblin-2api ç”Ÿäº§çŽ¯å¢ƒé…ç½®
# è¯¥æ–‡ä»¶ç”± Project Chimera è‡ªåŠ¨ç”Ÿæˆã€‚

# --- å®‰å…¨é…ç½® ---
API_MASTER_KEY=1

# --- ç«¯å£é…ç½® ---
NGINX_PORT=8088


--- æ–‡ä»¶è·¯å¾„: .env.example ---

# /.env.example
# ====================================================================
# goblin-2api é…ç½®æ–‡ä»¶æ¨¡æ¿
# ====================================================================
#
# è¯·å°†æ­¤æ–‡ä»¶é‡å‘½åä¸º ".env" å¹¶æŒ‰éœ€ä¿®æ”¹ã€‚
#

# --- æ ¸å¿ƒå®‰å…¨é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç”¨äºŽä¿æŠ¤æ‚¨ API æœåŠ¡çš„è®¿é—®å¯†é’¥ã€‚
API_MASTER_KEY=sk-goblin-2api-default-key-please-change-me

# --- éƒ¨ç½²é…ç½® (å¯é€‰) ---
# Nginx å¯¹å¤–æš´éœ²çš„ç«¯å£
NGINX_PORT=8088


--- æ–‡ä»¶è·¯å¾„: Dockerfile ---

# /Dockerfile
# ====================================================================
# Dockerfile for goblin-2api (v1.0 - Chimera Edition)
# ====================================================================

FROM python:3.10-slim

# è®¾ç½®çŽ¯å¢ƒå˜é‡
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ– (cloudscraper å¯èƒ½éœ€è¦)
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£… Python ä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºå¹¶åˆ‡æ¢åˆ°éž root ç”¨æˆ·
RUN useradd --create-home appuser && \
    chown -R appuser:appuser /app
USER appuser

# æš´éœ²ç«¯å£å¹¶å¯åŠ¨
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]


--- æ–‡ä»¶è·¯å¾„: docker-compose.yml ---

# /docker-compose.yml
services:
  nginx:
    image: nginx:latest
    container_name: goblin-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8088}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - goblin-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: goblin-2api-app
    restart: unless-stopped
    env_file:
      - .env
    networks:
      - goblin-net

networks:
  goblin-net:
    driver: bridge


--- æ–‡ä»¶è·¯å¾„: main.py ---

# /main.py
import logging
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse, StreamingResponse

from app.core.config import settings
from app.providers.goblin_provider import GoblinProvider

# --- æ—¥å¿—é…ç½® ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- å…¨å±€ Provider å®žä¾‹ ---
provider = GoblinProvider()

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info(f"åº”ç”¨å¯åŠ¨ä¸­... {settings.APP_NAME} v{settings.APP_VERSION}")
    logger.info("æœåŠ¡å·²è¿›å…¥ 'Cloudscraper & Pseudo-Stream' æ¨¡å¼ã€‚")
    logger.info(f"æœåŠ¡å°†åœ¨ http://localhost:{settings.NGINX_PORT} ä¸Šå¯ç”¨")
    yield
    logger.info("åº”ç”¨å…³é—­ã€‚")

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

# --- å®‰å…¨ä¾èµ– ---
async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="éœ€è¦ Bearer Token è®¤è¯ã€‚")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="æ— æ•ˆçš„ API Keyã€‚")

# --- API è·¯ç”± ---
@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)])
async def chat_completions(request: Request):
    try:
        request_data = await request.json()
        return await provider.chat_completion(request_data)
    except Exception as e:
        logger.error(f"å¤„ç†èŠå¤©è¯·æ±‚æ—¶å‘ç”Ÿé¡¶å±‚é”™è¯¯: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}")

@app.get("/v1/models", dependencies=[Depends(verify_api_key)], response_class=JSONResponse)
async def list_models():
    return await provider.get_models()

@app.get("/", summary="æ ¹è·¯å¾„", include_in_schema=False)
def root():
    return {"message": f"æ¬¢è¿Žæ¥åˆ° {settings.APP_NAME} v{settings.APP_VERSION}. æœåŠ¡è¿è¡Œæ­£å¸¸ã€‚"}


--- æ–‡ä»¶è·¯å¾„: nginx.conf ---

# /nginx.conf
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream goblin_backend {
        # ip_hash ç¡®ä¿æ¥è‡ªåŒä¸€å®¢æˆ·ç«¯çš„è¯·æ±‚è¢«è½¬å‘åˆ°åŒä¸€ä¸ª worker
        ip_hash;
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://goblin_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # æµå¼ä¼ è¾“ä¼˜åŒ–
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
        }
    }
}


--- æ–‡ä»¶è·¯å¾„: requirements.txt ---

# /requirements.txt
fastapi
uvicorn[standard]
pydantic-settings
python-dotenv
cloudscraper


--- æ–‡ä»¶è·¯å¾„: app\core\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\core\config.py ---

# /app/core/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional, Dict, List

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "goblin-2api"
    APP_VERSION: str = "1.0.0"
    DESCRIPTION: str = "ä¸€ä¸ªå°† goblin.tools è½¬æ¢ä¸ºå…¼å®¹ OpenAI æ ¼å¼ API çš„é«˜æ€§èƒ½ä»£ç†ã€‚"

    API_MASTER_KEY: Optional[str] = "1"
    NGINX_PORT: int = 8088

    # ä¸Šæ¸¸è¯·æ±‚é…ç½®
    API_REQUEST_TIMEOUT: int = 120

    # æ¨¡åž‹åç§°åˆ°ä¸Šæ¸¸ URL çš„æ˜ å°„
    MODEL_MAPPING: Dict[str, str] = {
        "è¯­æ°”è¯„åˆ¤": "https://goblin.tools/api/ToneJudger/JudgeTone",
        "å›žåº”å»ºè®®": "https://goblin.tools/api/ToneJudger/SuggestResponse",
    }
    DEFAULT_MODEL: str = "è¯­æ°”è¯„åˆ¤"

    @property
    def KNOWN_MODELS(self) -> List[str]:
        return list(self.MODEL_MAPPING.keys())

settings = Settings()


--- æ–‡ä»¶è·¯å¾„: app\providers\__init__.py ---



--- æ–‡ä»¶è·¯å¾„: app\providers\base_provider.py ---

# /app/providers/base_provider.py
from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass


--- æ–‡ä»¶è·¯å¾„: app\providers\goblin_provider.py ---

# /app/providers/goblin_provider.py
import time
import json
import uuid
import asyncio
import logging
from typing import Dict, Any, AsyncGenerator

import cloudscraper
from fastapi import HTTPException
from fastapi.responses import StreamingResponse, JSONResponse

from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

logger = logging.getLogger(__name__)

class GoblinProvider(BaseProvider):
    def __init__(self):
        self.scraper = cloudscraper.create_scraper()

    def _prepare_headers(self) -> Dict[str, str]:
        return {
            "Accept": "*/*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Content-Type": "application/json",
            "Origin": "https://goblin.tools",
            "Referer": "https://goblin.tools/Judge",
            "Cookie": "gt_lang=zh-CN",
        }

    def _prepare_payload(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
        messages = request_data.get("messages", [])
        last_user_message = next((m['content'] for m in reversed(messages) if m.get('role') == 'user'), None)
        
        if not last_user_message:
            raise HTTPException(status_code=400, detail="è¯·æ±‚ä¸­æœªæ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯ã€‚")
            
        return {"Texts": [last_user_message]}

    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        model = request_data.get("model", settings.DEFAULT_MODEL)
        upstream_url = settings.MODEL_MAPPING.get(model)

        if not upstream_url:
            raise HTTPException(status_code=400, detail=f"ä¸æ”¯æŒçš„æ¨¡åž‹: {model}")

        payload = self._prepare_payload(request_data)
        headers = self._prepare_headers()
        
        async def stream_generator() -> AsyncGenerator[bytes, None]:
            request_id = f"chatcmpl-{uuid.uuid4()}"
            loop = asyncio.get_running_loop()
            
            try:
                logger.info(f"å‘ {upstream_url} å‘é€è¯·æ±‚...")
                response = await loop.run_in_executor(
                    None, 
                    lambda: self.scraper.post(
                        upstream_url,
                        headers=headers,
                        json=payload,
                        timeout=settings.API_REQUEST_TIMEOUT
                    )
                )
                
                logger.info(f"ä¸Šæ¸¸æœåŠ¡è¿”å›žçŠ¶æ€ç : {response.status_code}")
                response.raise_for_status()
                
                full_text = response.text
                logger.info(f"æ”¶åˆ°å®Œæ•´å“åº”: {full_text[:100]}...")

                # æ¨¡å¼ï¼šä¼ªæµå¼ç”Ÿæˆ (Pseudo-Stream-Generation)
                for char in full_text:
                    chunk = create_chat_completion_chunk(request_id, model, char)
                    yield create_sse_data(chunk)
                    await asyncio.sleep(0.01) # æŽ§åˆ¶æ‰“å­—æœºé€Ÿåº¦

                final_chunk = create_chat_completion_chunk(request_id, model, "", "stop")
                yield create_sse_data(final_chunk)
                yield DONE_CHUNK
                logger.info("ä¼ªæµå¼ä¼ è¾“å®Œæˆã€‚")

            except Exception as e:
                logger.error(f"å¤„ç†æµæ—¶å‘ç”Ÿé”™è¯¯: {e}", exc_info=True)
                error_message = f"å†…éƒ¨æœåŠ¡å™¨é”™è¯¯: {str(e)}"
                error_chunk = create_chat_completion_chunk(request_id, model, error_message, "stop")
                yield create_sse_data(error_chunk)
                yield DONE_CHUNK

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    async def get_models(self) -> JSONResponse:
        model_data = {
            "object": "list",
            "data": [
                {"id": name, "object": "model", "created": int(time.time()), "owned_by": "lzA6"}
                for name in settings.KNOWN_MODELS
            ]
        }
        return JSONResponse(content=model_data)


--- æ–‡ä»¶è·¯å¾„: app\utils\sse_utils.py ---

# /app/utils/sse_utils.py
import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    return f"data: {json.dumps(data)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content},
                "finish_reason": finish_reason
            }
        ]
    }



